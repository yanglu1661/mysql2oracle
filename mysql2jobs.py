#!/usr/bin/python3
import os
import re
import pymysql
import configparser
import subprocess
from openai import OpenAI
from concurrent.futures import ThreadPoolExecutor, as_completed

# ======== 配置加载 ========
config = configparser.ConfigParser()
config.read('config.ini')

mysql_conf = config['mysql']
output_conf = config['ddl_output']
ai_conf = config['openai']

INPUT_DIR = output_conf.get('input_dir', 'mysql_schema_raw')
OUTPUT_DIR = output_conf.get('output_dir', 'oracle_schema_ddl')
MAX_WORKERS = int(ai_conf.get('max_workers', 5))

# ======== 创建 DeepSeek 客户端 ========
client = OpenAI(api_key=ai_conf['api_key'], base_url=ai_conf['api_base'])

# ======== AI 转换函数 ========
def convert_to_oracle_via_ai(mysql_sql: str) -> str:
    prompt = f"""
你是一个数据库迁移专家，必须将以下MySQL表结构精确转换为Oracle 23ai兼容的SQL DDL。

核心要求（必须严格遵守）：
1. 保留所有原始注释内容，包括表注释和列注释
2. 表注释使用: COMMENT ON TABLE 表名 IS '注释内容';
3. 列注释使用: COMMENT ON COLUMN 表名.列名 IS '注释内容';
4. 所有注释必须放在CREATE TABLE语句之后

转换规则：
- AUTO_INCREMENT → GENERATED BY DEFAULT AS IDENTITY，且确保最终形式为 "GENERATED BY DEFAULT AS IDENTITY"（移除可能存在的 NOT NULL）
- ENGINE=InnoDB 等存储引擎声明必须移除，且确保生成完整可执行的 SQL，字段定义在同一行
- DATETIME → TIMESTAMP，且 DEFAULT 子句需放在数据类型之后，约束（如 NOT NULL）之前
- TINYINT → NUMBER (3)，且 DEFAULT 子句需放在数据类型之后，约束（如 NOT NULL）之前
- TEXT 类型 → CLOB，且 DEFAULT 子句需放在数据类型之后，约束（如 NOT NULL）之前
- ENUM 类型 → VARCHAR2 并添加 CHECK 约束，且 DEFAULT 子句需放在数据类型之后，约束（如 NOT NULL）之前
- FLOAT (p,s) 和 DOUBLE (p,s) → NUMBER (p,s)，且 DEFAULT 子句需放在数据类型之后，约束（如 NOT NULL）之前
- 移除所有 "IF EXISTS" 语句，且确保生成完整可执行的 SQL，字段定义在同一行
- DEFAULT 子句需放在数据类型之后，约束（如 NOT NULL）之前
- 针对索引或主键转换为 Oracle constraint 时，需要添加表名作为前缀（如原约束为 udx_laguage_tag_code，表名为 language_info，则转换为 CONSTRAINT language_info_udx_laguage_tag_code UNIQUE (language_tag, code, deleted)），避免 constraint 重名错误

MySQL定义：
{mysql_sql}

输出格式（只返回SQL，无其他说明）：
CREATE TABLE ... (
  ...
);
COMMENT ON TABLE ...;
COMMENT ON COLUMN ...;
...

MySQL 定义如下：
{mysql_sql}
"""
    response = client.chat.completions.create(
        model="deepseek-chat",
        messages=[{"role": "user", "content": prompt}],
        max_tokens=4096
    )
    res = response.choices[0].message.content.strip()
    res = re.sub(r"^```(sql|plsql)?", "", res).replace("```", "").strip()
    return res

# ======== 导出所有表结构（含索引与约束） ========
def extract_table_ddl(conn, schema=None):
    cur = conn.cursor()

    # 获取所有表名
    if schema:
        cur.execute("SHOW TABLES")
    else:
        cur.execute("SHOW TABLES")

    tables = [row[0] for row in cur.fetchall()]

    os.makedirs(INPUT_DIR, exist_ok=True)
    print(f"发现 {len(tables)} 个表，开始导出...")

    for table in tables:
        filename = f"{table}.sql"
        filepath = os.path.join(INPUT_DIR, filename)
        try:
            # 获取表创建语句
            cur.execute(f"SHOW CREATE TABLE `{table}`")
            create_table_stmt = cur.fetchone()[1]

            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(create_table_stmt)
            print(f"✅ 导出表结构：{filename}")
        except Exception as e:
            print(f"❌ 导出失败：{filename}\n错误信息: {str(e)}")

def process_single_file(filename):
    try:
        input_path = os.path.join(INPUT_DIR, filename)
        with open(input_path, 'r', encoding='utf-8') as f:
            mysql_sql = f.read()

        print(f"🔄 正在转换：{filename}")
        oracle_sql = convert_to_oracle_via_ai(mysql_sql)

        # 调试：打印AI返回的内容
        print(f"AI返回内容:\n{oracle_sql}\n")

        # 首先检查AI返回的SQL是否已经是完整的
        if "CREATE TABLE" in oracle_sql and ";" in oracle_sql:
            # AI返回了完整的SQL，直接使用
            final_sql = oracle_sql
        else:
            # 使用改进的正则表达式匹配CREATE TABLE
            # 匹配整个CREATE TABLE语句，包括表名、列定义和表选项
            create_table_pattern = r'CREATE\s+TABLE\s+([^\s(]+)\s*\(([^)]+)\)\s*([^;]*);?'
            match = re.search(create_table_pattern, oracle_sql, re.DOTALL | re.IGNORECASE)
            
            if not match:
                # 如果正则匹配失败，尝试直接使用AI返回的内容
                print(f"⚠️ 无法解析CREATE TABLE语句，直接使用AI返回内容: {filename}")
                final_sql = oracle_sql
            else:
                table_name = match.group(1).strip('`"')
                columns_body = match.group(2)
                table_options = match.group(3).strip()
                
                # 处理列定义 - 按逗号分割，但要注意不要分割函数内部的逗号
                lines = []
                current_line = ""
                paren_depth = 0
                
                for char in columns_body:
                    if char == '(':
                        paren_depth += 1
                        current_line += char
                    elif char == ')':
                        paren_depth -= 1
                        current_line += char
                    elif char == ',' and paren_depth == 0:
                        lines.append(current_line.strip())
                        current_line = ""
                    else:
                        current_line += char
                
                if current_line.strip():
                    lines.append(current_line.strip())
                
                # 过滤空行并重新格式化
                cleaned_lines = [line for line in lines if line.strip()]
                
                # 重建CREATE TABLE语句
                create_table_sql = f"CREATE TABLE {table_name} (\n  " + ",\n  ".join(cleaned_lines) + "\n)"
                
                if table_options:
                    final_sql = f"{create_table_sql} {table_options};"
                else:
                    final_sql = f"{create_table_sql};"

        table_name = filename.replace('.sql', '')
        output_main_path = os.path.join(OUTPUT_DIR, f"{table_name}.oracle.sql")
        
        with open(output_main_path, 'w', encoding='utf-8') as f:
            f.write(final_sql.strip())
        
        print(f"✅ DDL文件写入：{output_main_path}")

    except Exception as e:
        print(f"❌ 转换失败：{filename}，错误：{e}")
        # 在错误时保存原始AI输出以便调试
        debug_path = os.path.join(OUTPUT_DIR, f"{filename}.debug")
        with open(debug_path, 'w', encoding='utf-8') as f:
            f.write(f"Original AI output:\n{oracle_sql}\n\nError: {e}")

# ======== 并发转换函数 ========
def convert_all_mysql_to_oracle_concurrently():
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    sql_files = [f for f in os.listdir(INPUT_DIR) if f.endswith('.sql')]

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = [executor.submit(process_single_file, file) for file in sql_files]
        for future in as_completed(futures):
            future.result()  # 捕获异常输出

# ======== 主函数入口 ========
def main():
    conn = pymysql.connect(
        host=mysql_conf['host'],
        port=mysql_conf.getint('port', 3306),
        user=mysql_conf['user'],
        password=mysql_conf['password'],
        database=mysql_conf['dbname'],
        charset='utf8mb4'
    )

    extract_table_ddl(conn)
    convert_all_mysql_to_oracle_concurrently()
    conn.close()

if __name__ == "__main__":
    main()
