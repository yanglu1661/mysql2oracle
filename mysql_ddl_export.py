#!/usr/bin/env python3
import os
import re
import pymysql
import configparser
import subprocess
from openai import OpenAI
from concurrent.futures import ThreadPoolExecutor, as_completed

# ======== 配置加载 ========
config = configparser.ConfigParser()
config.read('config.ini')

mysql_conf = config['mysql']
output_conf = config['ddl_output']
ai_conf = config['openai']

INPUT_DIR = output_conf.get('input_dir', 'mysql_schema_raw')
OUTPUT_DIR = output_conf.get('output_dir', 'oracle_schema_ddl')
MAX_WORKERS = int(ai_conf.get('max_workers', 5))

# ======== 创建 DeepSeek 客户端 ========
client = OpenAI(api_key=ai_conf['api_key'], base_url=ai_conf['api_base'])

# ======== AI 转换函数 ========
def convert_to_oracle_via_ai(mysql_sql: str) -> str:
    prompt = f"""
你是一个数据库迁移专家，请将以下 MySQL 表结构定义（包含索引和约束）转换为 Oracle 兼容的 SQL DDL。
仅以纯文本格式给我回复。回复不需要任何关于修改的内容的说明。
保留注释，去掉"IF EXISTS"语句，MySQL 的类型应转换为对应的 Oracle 类型。请使用标准 Oracle 语法。

特别注意以下转换规则：
1. AUTO_INCREMENT 转换为 Oracle 的 GENERATED BY DEFAULT AS IDENTITY
2. ENGINE=InnoDB 等存储引擎声明需要去掉
3. 将 DATETIME 转换为 TIMESTAMP
4. 将 TINYINT 转换为 NUMBER(3)
5. 将 TEXT 类型转换为 CLOB
6. 将 ENUM 类型转换为 VARCHAR2 并添加 CHECK 约束
7. 将 FLOAT(p,s) 和 DOUBLE(p,s) 转换为 NUMBER(p,s)

MySQL 定义如下：
{mysql_sql}
"""
    response = client.chat.completions.create(
        model="deepseek-chat",
        messages=[{"role": "user", "content": prompt}],
        max_tokens=4096
    )
    res = response.choices[0].message.content.strip()
    res = re.sub(r"^```(sql|plsql)?", "", res).replace("```", "").strip()
    return res

# ======== 导出所有表结构（含索引与约束） ========
def extract_table_ddl(conn, schema=None):
    cur = conn.cursor()
    
    # 获取所有表名
    if schema:
        cur.execute("SHOW TABLES")
    else:
        cur.execute("SHOW TABLES")
    
    tables = [row[0] for row in cur.fetchall()]

    os.makedirs(INPUT_DIR, exist_ok=True)
    print(f"发现 {len(tables)} 个表，开始导出...")

    for table in tables:
        filename = f"{table}.sql"
        filepath = os.path.join(INPUT_DIR, filename)
        try:
            # 获取表创建语句
            cur.execute(f"SHOW CREATE TABLE `{table}`")
            create_table_stmt = cur.fetchone()[1]
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(create_table_stmt)
            print(f"✅ 导出表结构：{filename}")
        except Exception as e:
            print(f"❌ 导出失败：{filename}\n错误信息: {str(e)}")

def process_single_file(filename):
    try:
        input_path = os.path.join(INPUT_DIR, filename)
        with open(input_path, 'r', encoding='utf-8') as f:
            mysql_sql = f.read()

        print(f"🔄 正在转换：{filename}")
        oracle_sql = convert_to_oracle_via_ai(mysql_sql)

        table_name = filename.replace('.sql', '')
        output_main_path = os.path.join(OUTPUT_DIR, f"{table_name}.oracle.sql")
        output_fk_path = os.path.join(OUTPUT_DIR, f"{table_name}.foreign_keys.sql")

        # 匹配 CREATE TABLE 语句
        create_table_match = re.search(r'CREATE TABLE\s+(\w+)\s*\((.*?)\);', oracle_sql, re.DOTALL | re.IGNORECASE)
        if not create_table_match:
            raise ValueError(f"无法解析 CREATE TABLE 语句：{filename}")

        table_name_in_ddl = create_table_match.group(1)
        table_body = create_table_match.group(2)

        lines = [line.strip() for line in table_body.split(',\n') if line.strip()]
        new_lines = []
        foreign_keys = []

        for line in lines:
            if re.search(r'\bFOREIGN\s+KEY\b', line, re.IGNORECASE):
                constraint_name = re.search(r'CONSTRAINT\s+(\w+)', line, re.IGNORECASE)
                constraint = constraint_name.group(1) if constraint_name else 'fk_unknown'
                foreign_keys.append(f"ALTER TABLE {table_name_in_ddl} ADD {line.strip()};")
            else:
                new_lines.append(line.strip())

        # 重建 CREATE TABLE
        create_table_sql = f"CREATE TABLE {table_name_in_ddl} (\n  " + ",\n  ".join(new_lines) + "\n);"

        # 把主 DDL 和索引语句提取出来
        rest_ddl = oracle_sql.split(");", 1)[-1].strip()
        final_main_sql = create_table_sql + ("\n\n" + rest_ddl if rest_ddl else "")

        with open(output_main_path, 'w', encoding='utf-8') as f:
            f.write(final_main_sql.strip())

        if foreign_keys:
            with open(output_fk_path, 'w', encoding='utf-8') as f:
                f.write('\n'.join(foreign_keys))
            print(f"✅ 外键文件写入：{output_fk_path}")
        else:
            print(f"⚠️ 无外键语句：{filename}")

        print(f"✅ DDL主文件写入：{output_main_path}")

    except Exception as e:
        print(f"❌ 转换失败：{filename}，错误：{e}")

# ======== 并发转换函数 ========
def convert_all_mysql_to_oracle_concurrently():
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    sql_files = [f for f in os.listdir(INPUT_DIR) if f.endswith('.sql')]

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = [executor.submit(process_single_file, file) for file in sql_files]
        for future in as_completed(futures):
            future.result()  # 捕获异常输出

# ======== 主函数入口 ========
def main():
    conn = pymysql.connect(
        host=mysql_conf['host'],
        port=mysql_conf.getint('port', 3306),
        user=mysql_conf['user'],
        password=mysql_conf['password'],
        database=mysql_conf['dbname'],
        charset='utf8mb4'
    )

    extract_table_ddl(conn)
    convert_all_mysql_to_oracle_concurrently()
    conn.close()

if __name__ == "__main__":
    main()
